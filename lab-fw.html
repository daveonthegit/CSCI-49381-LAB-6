<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="robots" content="index,nofollow">
    <title>CSCI 493-81 Firewalls</title>
    <link rel="stylesheet" type="text/css" charset="utf-8" media="all"
      href="css/common.css">
    <link rel="stylesheet" type="text/css" charset="utf-8"
      media="screen" href="css/screen.css">
  </head>
  <body dir="ltr" lang="en">
    <div id="page" dir="ltr" lang="en">
      <h1>CSCI 493-81 Firewall Security Lab<br>
      </h1>
      <span class="anchor" id="overview"></span>
      <p> <span class="anchor" id="reading"></span> </p>
      <p><span class="anchor" id="firewalls"></span> </p>
      <h2>Firewalls</h2>
      <h3>Stateless Firewalls</h3>
      <p>In the late 1980s, the Internet was just beginning to grow
        beyond its early academic and governmental applications into the
        commercial and personal worlds. The <a class="http"
          href="http://en.wikipedia.org/wiki/Morris_worm">Great Internet
          Worm</a> in November of 1988 infected around 6,000 hosts
        (roughly 10% of the Internet) in the first major infection of
        its kind and helped to focus research and awareness on securing
        computers from unauthorized access. It was in this environment
        that the first firewalls were written about and developed at
        Digital Equipment Corporation (DEC) and Bell Labs (AT&amp;T). </p>
      <p>The first functional firewalls inspected individual packet
        headers without regard for established connections, other
        packets, or their contents. These kind of firewalls became known
        as "packet filters" because they literally filtered the packets
        one by one according to a set of criteria, not unlike a quality
        control inspector on an assembly line. For TCP and UDP, these
        criteria could be reduced essentially to the source and
        destination addresses and ports in the packet header. For
        example, a packet filter could reject or drop any packets
        destined for port 23 (telnet) on host 10.10.10.10 from any
        address other than 10.10.10.11. This kind of filter could
        rapidly and inexpensively inspect and classify packets without
        using much space (although they were not very "smart"). </p>
      <p>Unsurprisingly, simple packet filters are not adequate for many
        applications, such as the <a class="http"
          href="http://en.wikipedia.org/wiki/Ftp">File Transfer Protocol</a>
        (FTP), because these protocols open additional connections on
        random ports that can not be anticipated or recognized by the
        firewall since it does not understand or consider the state of
        any connection. </p>
      <p>This kind of simple "packet filter" ultimately became known as
        a "stateless firewall". </p>
      <h3>Stateful Firewalls</h3>
      <p>"Stateful firewalls" arrived not long after "stateless
        firewalls". Stateful firewalls keep tables of network
        connections and states in memory in order to SPHEREmine if a
        packet is part of a preexisting network connection, the start of
        a new and legitimate connection, or an unwanted or unrelated
        packet. This kind of firewall can recognize, for example, that a
        new connection on a random high port from a host with a
        preexisting FTP connection is a related connection and should be
        allowed. Another difference is that while a stateless firewall
        will allow all packets from acceptable hosts to an open port, a
        stateful firewall can be configured to allow packets to that
        port only if a legitimate TCP connection (or some other
        protocol) has already been established in some acceptable way.
        Understanding protocol state essentially gives stateful
        firewalls vastly more criteria in deciding whether to accept or
        reject a packet, which translates into finer granularity. </p>
      <p>The cutting edge of firewall design today is what is called an
        "application-layer firewall", which is a firewall that performs
        "deep packet inspection". This means that the firewall is
        capable of looking not just at the header of the packets and the
        state of the connection, but at the payload of the packet in
        context of what the application processing the packets will do.
        For example, an application-layer firewall could be used to
        block Java applets from HTTP traffic by inspecting the packets
        and stripping Java code or dropping the packets entirely. In
        order to do this, it must understand what applet code looks like
        within the payload portion of any HTTP traffic stream. An
        application-layer firewall essentially has total control over
        the network stream, although this control comes at a significant
        expense in terms of CPU time and software complexity. </p>
      <p>Most firewalls in use today lie somewhere between the stateful
        firewall and the application-layer firewall. These firewalls
        function essentially as a stateful firewall, but may understand
        enough of a few applications to perform some application-layer
        tasks. It is also common to couple a primarily stateful firewall
        (such as netfilter/iptables) with separate application layer
        firewalls for individual applications. </p>
      <p><span class="anchor" id="policy"></span> </p>
      <h3>Firewall Policy Design</h3>
      <p>People imagine many different things when they hear the term "<a
          class="http" href="http://en.wikipedia.org/wiki/Firewall">firewall</a>"
        in the context of computer networking. Some envision an
        impenetrable wall of flame <em>[at least I did --ed.]</em>. A
        Hollywood screenwriter might envision Harrison Ford battling
        kidnappers. A mechanic might envision the wall between the
        engine and passenger compartment of a car. Yet mysteriously,
        every firewall is illustrated as a boring, red brick wall,
        typically with no fire in sight. </p>
      <p>Actually, the brick wall isn't that strange -- the name
        "firewall" comes from the brick walls in buildings placed to
        stop the spread of a fire from one area to another. But no
        matter who you are or what you see in your minds eye, the
        conventional wisdom is that firewalls are used to "keep the bad
        stuff out," whether you're protecting your desktop PC at home,
        your office LAN, or the Pentagon. However, those of us in the
        field of computer security often see firewalls more as a means
        of keeping things <em>in</em> rather than keeping them <em>out</em>.
      </p>
      <p>In one sense, these are two sides of the same coin -- but how
        you design something is (often unconsciously) directly related
        to how you view the problem, and this can lead to very different
        design choices when developing a firewall. The goal of "keeping
        things out" is by definition, exclusively concerned with keeping
        external attackers "outside" the system, with no regard for what
        is inside that is worth protecting, and without considering
        threats (intentional or unintentional) that are <em>already</em>
        inside, like malicious or foolish employees. This is only half
        the picture. In contrast, "keeping things in" by definition
        concerns itself with what is "inside" like sensitive data,
        privileged access, etc., and encourages the designer to consider
        <em>all</em> threats -- both internal and external -- against
        the protected resource. </p>
      <p>Practically speaking, these two goals often result in different
        default policies. The goal of "keeping things out" often results
        in a policy that by default allows anything not considered to be
        a threat. This is called a <strong>default allow</strong>
        policy, and the classic example of this kind of firewall allows
        <strong>all</strong> outbound traffic, but only allows
        "untrusted" inbound traffic to special services, such as a web
        server (which is then responsible for its own security). This is
        better than nothing, but is hardly secure. If an attacker can
        trick someone inside into opening a <a class="http"
          href="http://en.wikipedia.org/wiki/Trojan_horse_(computing)">trojan







          horse</a>, the malicious software can exploit the liberal
        egress policy by making connections to a malicious host on the
        Internet, which can be used to send messages to the
        now-compromised system. Incidentally, this is how the firewalls
        on most home routers are designed. </p>
      <p>On the other hand, the "keeping things in" policy usually
        results in a policy that by default <em>denies everything</em>,
        and allows only what is necessary for the proper functioning of
        a system. This embodies the principle of "<a class="http"
          href="http://en.wikipedia.org/wiki/Principle_of_least_privilege">least







          privilege</a>" and in the context of a firewall is called a <strong>default







          deny</strong> policy. A firewall configured this way allows
        only the handful of things that are strictly required. This
        limits inbound traffic as before, but also only allows outbound
        traffic to carefully chosen targets. For example, this might
        only allow oubound traffic to a secured mail server, ssh server,
        and the few web servers required for an employee to accomplish
        their job. This drastically limits the means by which traffic
        can enter <em>or</em> leave the network, and if an employee
        executes a trojan as in the last example, that malicious
        software will not be able to contact its evil master because the
        malicious Internet host will almost certainly not be in the list
        of allowed outbound connections. </p>
      <p>The obvious downside to a "default deny" firewall policy is
        maintenance and inconvenience -- it is harder to install in the
        first place, and any new network service or traffic type on the
        network must be explicitly allowed or it will not function.
        Allowing all outbound traffic significantly cuts down on this
        kind of maintenance -- at the cost of security. <span
          class="anchor" id="nettools"></span> </p>
      <h3>Firewall and Network Testing Tools</h3>
      <span class="anchor" id="netfilter"></span>
      <h4>iptables: set and clear rules in netfilter</h4>
      <p> <a class="http" href="http://en.wikipedia.org/wiki/Iptables">iptables</a>
        is actually the user space tool for administering the <tt>netfilter</tt>
        functions and tables in the Linux kernel, but the entire <tt>netfilter</tt>
        and <tt>iptables</tt> package is commonly referred to simply as
        <tt>iptables</tt>. <tt>iptables</tt> has several built-in
        tables of rules (such as <tt>filter</tt> and <tt>nat</tt>) ,
        several built-in "chains" (which are sets of network traffic
        including the built-in INPUT, OUTPUT, and FORWARD for inbound,
        outbound, and routed traffic), a set of powerful loadable
        modules of matching stateful filters, the typical set of
        stateless criteria (such as source, destination, and interface),
        and a set of targets that represent what to do with a matching
        packet. These options allow sophisticated firewalls to be
        defined. </p>
      <p> <tt>iptables</tt> can be intimidating and confusing at first
        glance even for veteran sysadmins, but especially to users who
        are not used to configuring firewalls at all or are used to
        configuring firewalls through a GUI. <tt class="backtick">iptables</tt>
        expressive plugins further complicate the syntax. A typical <tt>iptables</tt>
        command looks something like this: </p>
      <p> </p>
      <pre>$ iptables -t filter -i ethX -A INPUT -m state --state NEW -p tcp -s 192.168.0.1 --dport 23 -j REJECT
</pre>
      <p> Upon closer inspection, <tt>iptables</tt> is revealed to be
        merely a command whose arguments define a single rule for packet
        filtering based on a number of possible criteria. <tt>iptables</tt>
        takes those arguments translates them one command at a time into
        priority-ordered filter rules in the Linux kernel. Thinking of <tt>iptables</tt>
        as a command with arguments can help demystify <tt>netfilter</tt>
        and the process of designing firewalls with <tt>iptables</tt>
        -- let's break down the above <tt class="backtick">iptables</tt>
        command and translate it into English: </p>
      <div>
        <table style="width: 800px">
          <tbody>
            <tr>
              <td colspan="2" style="text-align: center;">
                <p> <strong>iptables command arguments</strong> </p>
              </td>
            </tr>
            <tr>
              <td>
                <p> <strong>command/argument</strong> </p>
              </td>
              <td>
                <p> <strong>translation</strong> </p>
              </td>
            </tr>
            <tr>
              <td>
                <p> <tt class="backtick">iptables</tt> </p>
              </td>
              <td>
                <p> <em>We're going to use the iptables tool to insert
                    a new rule into netfilter.</em> </p>
              </td>
            </tr>
            <tr>
              <td>
                <p> <tt class="backtick">-t&nbsp;filter</tt> </p>
              </td>
              <td>
                <p> <em>This rule is going to go in the filter table,
                    which is the built-in packet filtering table. This
                    rule will apply only to:</em> </p>
              </td>
            </tr>
            <tr>
              <td>
                <p> <tt class="backtick">-i eth0</tt> </p>
              </td>
              <td>
                <p> <em>packets that are inbound on device <tt>ethX</tt>
                    (use <tt>-o ethX</tt> to match outbound packets)
                    and which:</em> </p>
              </td>
            </tr>
            <tr>
              <td>
                <p> <tt class="backtick">-A&nbsp;INPUT</tt> </p>
              </td>
              <td>
                <p> <em>packets that have been put into the <tt>INPUT</tt>
                    chain either by the kernel or by some previous rule
                    (use <tt>OUTPUT</tt> for the OUTPUT chain) and
                    which:</em> </p>
              </td>
            </tr>
            <tr>
              <td>
                <p> <tt class="backtick">-m&nbsp;state&nbsp;--state&nbsp;NEW</tt>
                </p>
              </td>
              <td>
                <p> <em>represent a new connection,</em> </p>
              </td>
            </tr>
            <tr>
              <td>
                <p> <tt class="backtick">-p&nbsp;tcp</tt> </p>
              </td>
              <td>
                <p> <em>are Transmission Control Protocol (TCP)
                    packets,</em> </p>
              </td>
            </tr>
            <tr>
              <td>
                <p> <tt class="backtick">-s&nbsp;192.168.0.1</tt> </p>
              </td>
              <td>
                <p> <em>are from the host 192.168.0.1,</em> </p>
              </td>
            </tr>
            <tr>
              <td>
                <p> <tt class="backtick">--dport&nbsp;23</tt> </p>
              </td>
              <td>
                <p> <em>and are destined for port 23.</em> </p>
              </td>
            </tr>
            <tr>
              <td>
                <p> <tt class="backtick">-j&nbsp;REJECT</tt> </p>
              </td>
              <td>
                <p> <em>Reject any matching packet. Processing of all
                    packets matching this rule will instantly jump to
                    the built-in target REJECT, which means that the
                    packet will be rejected by the kernel with some kind
                    of network error message.</em> </p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <p> A few other examples: </p>
      <p> </p>
      <pre>$ iptables -p tcp --syn --dport 23 -m connlimit --connlimit-above 2 -j REJECT
</pre>
      <p> This rule (from <tt>man&nbsp;iptables</tt>) allows 2 telnet
        connections per client host. Note that this rule uses the <tt>connlimit</tt>
        matching module, and rejects additional connections. </p>
      <p> </p>
      <pre>$ iptables -A INPUT -i lo -j ACCEPT
$ iptables -A OUTPUT -o lo -j ACCEPT
</pre>
      <p> These rules accepts any inbound or outbound traffic on the
        internal loopback network device (an internal, logical network
        adapter the kernel uses for network communication internal to
        the computer) regardless of state, protocol, source, or
        destination address. The <tt>-i&nbsp;lo</tt> and <tt>-o&nbsp;lo</tt>
        arguments specify the "input interface" and "output interface"
        the packet arrived on. </p>
      <p> </p>
      <pre>$IPTABLES -t filter -A INPUT -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT
$IPTABLES -t filter -A OUTPUT -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT
</pre>
      <p> These rules accept all INBOUND and OUTBOUND traffic regardless
        of interface, address, port or protocol. They use the <tt>state</tt>
        matching module, but accept all NEW, RELATED, and ESTABLISHED
        packets (which is basically all traffic). This rule is basically
        like having no firewall at all! </p>
      <p> <strong>NEW, RELATED, ESTABLISHED</strong> </p>
      <p> Think of your firewall as a security checkpoint in a big
        office building. There's usually two lines -- one for people
        with IDs, and one for people without IDs. If someone already has
        an ID, they can skip the long line, and go through. If they
        don't, they have to wait to get an ID card or visitor's pass.
        This is analogous to the distinction between <strong>NEW</strong>
        traffic versus <strong>RELATED</strong> or <strong>ESTABLISHED</strong>
        traffic (which you usually see together). Traffic marked <strong>NEW</strong>
        doesn't have an ID badge yet, because it is the first packet of
        a new stream of traffic. On the other hand, a packet of a <strong>RELATED</strong>
        or <strong>ESTABLISHED</strong> stream is part of something
        that by definition has already come through the firewall in the
        past. In other words, the firewall has already given that stream
        a "badge" (which is really an entry in an internal firewall data
        structure). </p>
      <p> Among other things, this means that firewalls are typically
        structured so that the first section passes all accepted <strong>RELATED,ESTABLISHED</strong>
        traffic first, and then carefully allows only certain kinds of <strong>NEW</strong>
        traffic. Why do it in that order? </p>
      <p> While this brief introduction to <tt>iptables</tt> should
        point you in the right direction, there are other features of <tt>iptables</tt>
        not included here that you may want to use for the exercise.
        There are many HOWTOs, tips, and tutorials online in addition to
        the <tt>iptables</tt> manpage; the exercise manual assumes that
        in order to complete the <tt>iptables</tt> exercise, you will
        need to <a class="http" href="http://www.google.com">do some
          research</a> on your own. <span class="anchor" id="nmap"></span>
      </p>
      <h4>nmap: network mapping port scanner</h4>
      <p> <a class="http" href="http://en.wikipedia.org/wiki/Nmap">Nmap</a>
        (<a class="http" href="http://www.insecure.org">homepage</a>) is
        a very popular "<a class="http"
          href="http://en.wikipedia.org/wiki/Port_scanner">port scanner</a>"
        that can be used to SPHEREmine what kind of services are running
        on a remote or local host, perform <a class="http"
          href="http://en.wikipedia.org/wiki/Passive_OS_Fingerprinting">OS







          fingerprinting</a>, and many other tasks. Nmap is capable of
        performing many tasks in a "stealth mode" designed to not raise
        the suspicion of the victim, but some tasks require more obvious
        techniques. </p>
      <p> Nmap is incredibly powerful, but the basic functionality of
        the application is easy to use: </p>
      <p> </p>
      <pre>$ sudo nmap yahoo.com

Starting Nmap 4.20 ( http://insecure.org ) at 2007-09-22 21:33 PDT
Warning: Hostname yahoo.com resolves to 2 IPs. Using 216.109.112.135.
Interesting ports on w2.rc.vip.dcn.yahoo.com (216.109.112.135):
Not shown: 1694 filtered ports
PORT    STATE SERVICE
25/tcp  open  smtp
80/tcp  open  http
443/tcp open  https

Nmap finished: 1 IP address (1 host up) scanned in 29.990 seconds

$ sudo nmap www.somehost.edu -P0
Starting Nmap 4.20 ( http://insecure.org ) at 2007-09-22 21:34 PDT
Interesting ports on dns.somehost.edu (33.xx.111.1):
Not shown: 1677 filtered ports
PORT     STATE  SERVICE
53/tcp   open   domain
80/tcp   open   http
443/tcp  open   https
2048/tcp open   dls-monitor
2049/tcp closed nfs
2053/tcp open   knetd
2064/tcp closed dnet-keyproxy
2065/tcp open   dlsrpn
2067/tcp open   dlswpn
2068/tcp open   advocentkvm
2105/tcp open   eklogin
2106/tcp open   ekshell
2108/tcp open   rkinit
2111/tcp open   kx
2112/tcp open   kip
2120/tcp open   kauth
2121/tcp open   ccproxy-ftp
2201/tcp open   ats
2232/tcp open   ivs-video
2241/tcp closed ivsd

Nmap finished: 1 IP address (1 host up) scanned in 32.385 seconds
</pre>
      <p> See the Nmap manpage or online documentation for advanced
        features. </p>
      <p> <span class="anchor" id="ifconfig"></span> </p>
      <h4>ifconfig: configure Linux network devices</h4>
      <p> <a class="http" href="http://en.wikipedia.org/wiki/Ifconfig">ifconfig</a>
        is the network interface configurator in Linux. It is most
        commonly used by users to see network addresses and statistics,
        but can also be used to enable and disable interfaces, set
        configuration options such as network addresses, and more. </p>
      <p> For the purposes of this exercise, <tt class="backtick">ifconfig</tt>
        will be used to SPHEREmine what network addresses are running on
        what interfaces. </p>
      <p> To see the current interface configurations: </p>
      <p> </p>
      <pre>$ ifconfig

eth0      Link encap:Ethernet  HWaddr 00:00:5A:00:01:B3
          inet addr:64.81.0.256  Bcast:64.81.40.255  Mask:255.255.255.0
          inet6 addr: fe80::200:5aff:fe00:1b3/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1826346 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1887951 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:691689933 (659.6 MiB)  TX bytes:1037280707 (989.2 MiB)
          Interrupt:58

eth1      Link encap:Ethernet  HWaddr 00:13:D4:04:44:CA
          inet addr:10.10.10.10  Bcast:10.10.10.255  Mask:255.255.0.0
          inet6 addr: fe80::213:d4ff:fe04:44ca/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1165519 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1549057 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:428484191 (408.6 MiB)  TX bytes:1780325755 (1.6 GiB)
          Interrupt:50

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:5808042 errors:0 dropped:0 overruns:0 frame:0
          TX packets:5808042 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:6895907043 (6.4 GiB)  TX bytes:6895907043 (6.4 GiB)
</pre>
      <p> Note that <tt class="backtick">eth0</tt>'s address is
        64.81.0.256, while <tt>eth1</tt>'s address is 10.10.10.10. This
        means that the two interfaces are on different networks. <span
          class="anchor" id="telnet"></span> </p>
      <h4>telnet: cleartext remote shell</h4>
      <p> <a class="http" href="http://en.wikipedia.org/wiki/Telnet">TELNET</a>
        (TELe-NETwork) is a cleartext remote terminal protocol. On its
        face, telnet is very simple; the user issues commands over a TCP
        socket, and the server replies with the results of those
        commands and waits for more input. In practice, this is
        complicated with various network and terminal emulation layers.
        Still, telnet is one of the simplest and oldest network
        protocols still in use. Due to its cleartext nature and low
        level access to the system, telnet is incredibly insecure -- it
        was common in the past for system administrators to log in as
        root using telnet on a hub network connection that could be
        sniffed by any sufficiently prepared attacker. </p>
      <p> Thanks to the advent of Secure Shell (ssh), active use of
        telnet servers has died off except for some specialized uses.
        One place where telnet lives on is debugging ASCII-based network
        services. For example, web pages can be retrieved by telnetting
        to HTTP servers, and emails can be sent by telnetting to SMTP
        servers. </p>
      <p> Telnetting to a suspected open port is still one of the
        fastest ways to see if a service is available or reachable. </p>
      <p> Here are a few sample uses of telnet: </p>
      <p> </p>
      <pre>$ telnet yahoo.com 80

Trying 66.94.234.13...
Connected to yahoo.com.
Escape character is '^]'.
GET /
...

&lt;html&gt;&lt;head&gt; ...[web page data] ...
&lt;/body&gt;
&lt;/html&gt;

Connection closed by foreign host.
</pre>
      <p> </p>
      <pre>$ telnet mailserver.net 25
Trying 216.0.1.1...
Connected to mailserver.net.

Escape character is '^]'.
220 mailserver.net ESMTP Postfix (Ubuntu)
HELO sender.net
250 sender.net
MAIL FROM: me@sender.net
250 Ok
RCPT TO: me@mailserver.net
250 Ok
DATA
354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;
Subject: test mail message
test message
.

250 Ok: queued as 152CFB8802A
^]

telnet&gt; Connection closed.

You have mail in /var/mail/me
</pre>
      For this exercise, you will use <tt>telnet</tt> to test if a TCP
      port is open on a remote host. Telnetnetting to an IP and port
      (see above) should return a "connected" message if it is possible
      to connect to a running server. <span class="anchor" id="netcat"></span>
      <span class="anchor" id="nc"></span>
      <h4>netcat: a network swiss army knife</h4>
      <p> netcat (often <tt class="backtick">nc</tt> on some systems)
        is a Unix utility for creating and using TCP and UDP sockets. In
        a very simplified way, <tt class="backtick">netcat</tt> is like
        a telnet client and server without any built in protocol or
        terminal emulation. Another way of putting it is that <tt
          class="backtick">netcat</tt> is the bare essentials for
        creating a TCP or UDP socket and client, with hooks for using
        standard in and standard out for IO. </p>
      <p>There are too many cool uses of netcat to describe here. For
        the purposes of this exercise, we'll use netcat to create "fake"
        TCP or UDP servers that we can use to test firewall
        configurations. </p>
      <h5>Creating fake TCP/UDP servers with netcat</h5>
      <p> Starting a fake listening server (a program that will accept
        connections on a port) is as simple as running: </p>
      <p> </p>
      <pre>$ sudo nc -l 80         # we need sudo because 80 is a privileged port
</pre>
      <p> ... to start a listening TCP socket on port 80. Then, from the
        another host, you can either use telnet or nc to connect to the
        server you just started on the the first host. You should be
        able to type in one window and see output in the other if the
        network pipe is open. </p>
      <p> Testing UDP services is exactly the same -- you can use netcat
        for that, too. You need to start a listening UDP process on the
        receiving side, and a sending process on the sending side. If
        you are testing UDP traffic from a client to a server, you can
        do something like this: </p>
      <p> </p>
      <pre>[server]$ nc -u -l 10000        # listen for UDP traffic on port 10000
</pre>
      <p> Then on the client, do something like this: </p>
      <p> </p>
      <pre>[client]$ nc -u server 10000    # connect to server via UDP on port 10000
</pre>
      <p> After establishing the connection, enter some data from
        standard input (probably your keyboard). Input on the sender
        should appear on the receiving terminal. Hit ^C to close the
        programs. UDP is of course an unreliable network protocol, so
        it's possible that there will be errors in the text file. </p>
      <p> You can do any of this in reverse to test the connection from
        a server to a client. If you're able to transmit data, then the
        firewall is allowing communication. <span class="anchor"
          id="intro"></span> </p>
      <div class="level3">
        <p>Please read the helpful advice in the next section for
          configuring and testing your firewall. </p>
      </div>
      <span class="anchor" id="tips"></span>
      <div class="level3">
        <h3>Tips and Tricks</h3>
        This section includes important rules and tips for making sure
        that your answers are correct.
        <p> <span class="anchor" id="envvars"></span> </p>
        <h4>Use Environment Variables in your firewall.sh!</h4>
        <p>Your firewall script is only supposed to limit the traffic on
          the "experimental network" interface, as opposed to including
          the "control network" of SPHERE. If you block the control
          network, you're likely to lose connection to your node, or
          shut off networked file systems, etc. </p>
        <p>Unfortunately, different SPHERE nodes (the physical computers
          you are given) bring up their networks on different interfaces
          (and in general you can't control which nodes you get). This
          means that on one node, the experimental network might be on
          eth0, and on another node, it might be on eth4 (or any other
          ethN). This makes writing your script difficult because it is
          not 100% portable from one node to another. </p>
        <p>However, we can use an environment variable to substitute in
          the right interface. In the firewall.sh script, there is a
          variable declaration: </p>
        <p> </p>
        <pre>ETH="eth0"
</pre>
        <p>You can use this variable with the token $ETH -- the shell
          will substitute in its value at runtime. Use ifconfig to make
          sure that ETH is set to the right value for your experimental
          node (or update it). For example, use ETH in a hypothetical
          iptables command like this: </p>
        <p> </p>
        <pre>iptables -A INPUT -i $ETH -j ACCEPT
</pre>
        <p>This way, you only need to update the ETH variable if your
          interface changes, rather than every iptables call that
          specifies an interface. </p>
        <p> <span class="anchor" id="fwtest"></span> </p>
        <h4>How to test your firewall</h4>
        <p>Testing your firewall is easy; you just need to make sure
          that the allowed services are allowed, and that things that
          should be denied are denied. To do that, we'll use a few tools
          like telnet, netcat, and others. </p>
        <p>You may also have noticed that this experiment swaps in two
          nodes instead of one. One will be called <tt>client</tt> and
          the other will be called <tt>server</tt>. <tt>server</tt> is
          the node with the firewall and resources you want to protect,
          but you can use client to check to see if the firewall is
          doing its job. You can also use client as a target to see if
          the server's outbound rules are functioning properly, using
          tools such as nmap, telnet, nc, and others in the <a
            href="#nmap" moz-do-not-send="true">network tools portion of
            this document</a>. </p>
        <p>The following tests have been provided by Dr. Tanya Crenshaw
          from the University of Portland. While these test cases cannot
          guarantee a perfect firewall, they should help you understand
          if your firewall is meeting the guidelines. </p>
        <h5>Firewall Test Cases</h5>
        <div class="warning">
          <p> <img src="idea.png"> <b>c$</b> indicates tests run from
            client node and <b>s$</b> indicates tests run from the
            server node </p>
          <p> </p>
        </div>
        <p> </p>
        <table>
          <tbody>
            <tr>
              <td> # </td>
              <td width="200"> Rule </td>
              <td> Test </td>
              <td width="200"> Result </td>
            </tr>
            <tr>
              <td> 1 </td>
              <td> Allow inbound traffic to the OpenSSH port. </td>
              <td>
                <pre>c$ telnet server 22
Trying 10.0.1.2...
Connected to server.
Escape character is '^]'.
SSH-1.99-OpenSSH_4.2
</pre>
              </td>
              <td> SUCCESS: A connection on port 22 is established using
                the telnet tool. </td>
            </tr>
            <tr>
              <td> 2 </td>
              <td> Allow outbound ssh traffic (established). </td>
              <td>
                <pre>See well-formed reply from ssh server in Test #1:

‘SSH-1.99-OpenSSH_4.2’
</pre>
              </td>
              <td> SUCCESS: The ssh server running on the server node
                replies to telnet’s connection request with the SSH
                version number. </td>
            </tr>
            <tr>
              <td> 3 </td>
              <td> Allow inbound traffic to http traffic. </td>
              <td>
                <pre>c$ telnet server 80              
Trying 10.0.1.2...
Connected to server.
Escape character is '^]'. 
</pre>
              </td>
              <td> SUCCESS: A connection on port 80 is established using
                the telnet tool. </td>
            </tr>
            <tr>
              <td> 4 </td>
              <td> Allow outbound http traffic (established). </td>
              <td>
                <pre>c$ nc -q 1 server 80 &lt;&lt;&lt; "GET /"
</pre>
                <p>Any response from the web server, including a "400
                  Bad Request"</p>
              </td>
              <td> SUCCESS: The Apache Web Server running on the server
                node replies to the client’s request. </td>
            </tr>
            <tr>
              <td> 5 </td>
              <td> Allow inbound and outbound mySQL traffic </td>
              <td>
                <pre>c$ [client]$ telnet server 3306            
Trying 10.0.1.2...
Connected to server.         
Escape character is '^]'.
K#HY000Host 'client-link0' is not allowed to connect to this MySQL serverConnection closed by foreign host.

</pre>
              </td>
              <td> SUCCESS: Connect to the MySQL server running on the
                server node using the telnet tool. Please note that
                although the firewall allows connections to MySQL (as
                shown by the phrase "Connected to server"), the MySQL
                server itself may respond with an error indicating that
                the host <tt>client</tt> is not allowed to connect to
                MySQL. You don't need to worry about that. </td>
            </tr>
            <tr>
              <td> 6 </td>
              <td> Allow new inbound ping traffic. </td>
              <td>
                <pre>c$ ping server
PING server-link0 (10.0.1.2) 56(84) bytes of data.
64 bytes from server-link0 (10.0.1.2): icmp_seq=0 ttl=64 time=0.412 ms


</pre>
              </td>
              <td> SUCCESS: Ping request from client is replied to by
                server. Note that request is new traffic, while reply is
                established traffic. </td>
            </tr>
            <tr>
              <td> 7 </td>
              <td> Allow new outbound ping traffic. </td>
              <td>
                <pre>s$ ping client
PING client-link0 (10.0.1.1) 56(84) bytes of data.
64 bytes from client-link0 (10.0.1.1): icmp_seq=0 ttl=64 time=0.302 ms


</pre>
              </td>
              <td> SUCCESS: Ping request from server is replied to by
                client. Note that request is new traffic, while reply is
                established traffic. </td>
            </tr>
            <tr>
              <td> 8 </td>
              <td> Allow inbound UDP traffic on ports 10000:10005 </td>
              <td>
                <pre>s$ nc -u -l 10000
hello

c$ nc -u server 10000
  (type ‘hello’)

</pre>
              </td>
              <td> SUCCESS: Traffic is allowed into the server on port
                10000. Run the same test for 10001:10005. </td>
            </tr>
            <tr>
              <td> 9 </td>
              <td> Allow outbound UDP traffic on ports 10006:10010 </td>
              <td>
                <pre>c$ nc -u -l 10006
hello

s$ nc -u client 10006
  (type ‘hello’)

</pre>
              </td>
              <td> SUCCESS: Traffic is allowed out of the server on port
                10006. Run the same test for 10007:10010. </td>
            </tr>
            <tr>
              <td> 10 </td>
              <td> Disallow all other traffic </td>
              <td>
                <p>We need to test other ports to make sure that all
                  other network traffic is blocked. However, most ports
                  do not have any services listening on them.
                  Fortunately, we can open ports manually using the <tt>nc</tt>
                  tool. To open a port on <tt>server</tt>, execute:</p>
                <pre>s$ nc -l PORTNUM</pre>
                <p> </p>
                <p>Then, on <tt>client</tt>, use <tt>telnet</tt> to
                  attempt to connect to the open port:</p>
                <pre>c$ telnet server PORTNUM</pre>
                <p>If traffic is being dropped, <tt>telnet</tt> should
                  hang; if it is hung, try pressing ^C to quit. If
                  traffic is being rejected, you will get a "connection
                  refused" message.</p>
                <br>
                <p>In order to test the firewall in the other direction,
                  you can reverse these commands -- that is, open ports
                  on <tt>client</tt> and try to reach them from <tt>server</tt>.</p>
                <br>
                <p>Finally, a failure to connect with this test <i>could</i>
                  be a <i>false negative</i>. For example, if you are
                  performing the test incorrectly, you might get a hang
                  or a rejection -- but not because the firewall is
                  working properly. Therefore, it is a good idea to do
                  this test with the firewall up <i>and</i> down. With
                  the firewall down, you should be able to connect to
                  the open port. Typing in <tt>telnet</tt> will make
                  characters appear on the <tt>nc</tt> side. Quit by
                  quitting <tt>nc</tt> with ^C or by closing telnet
                  (pressing ^] and then entering "quit").</p>
              </td>
              <td> SUCCESS: If the firewall is passively blocking
                traffic, connections should hang. Of course, this will
                only test individual ports you try. A comprehensive test
                would use a script to test every port and test UDP in
                addition to TCP, etc. A strong firewall design should
                ensure that all traffic is dropped except that which is
                explicitly accepted. </td>
            </tr>
            <tr>
              <td> 11 </td>
              <td> Prevent spoofing </td>
              <td>
                <pre>Straightforward test unknown

</pre>
              </td>
              <td> NA </td>
            </tr>
          </tbody>
        </table>
      </div>
      <span class="anchor" id="glitches"></span>
      <div class="level3">
        <h3>What can go wrong</h3>
        <h4>Your firewall cuts off your access to the node.</h4>
        <p>If you have misconfigured your firewall, and it "locks you
          out," you can try to reboot your experimental nodes using the
          SPHERE interface. If that does not work, you will need to swap
          your nodes out and back in again, but beware that swapping
          your nodes out will destroy any work you have not backed up in
          your home directory. </p>
        <p>Make sure you are using the environment variable to define
          the interface you are restricting -- this will help keep you
          from getting "locked out." See the <a href="#tips">tips and
            tricks</a> section for more information.<br>
        </p>
        <h3>Firewall Resources:</h3>
        <ul>
          <li>You can find some useful tools such as <a
              href="http://easyfwgen.morizot.net/gen/index.php">Easy
              Firewall Generator for IPTables</a></li>
          <li><a href="http://www.faqs.org/faqs/firewalls-faq/">Firewalls






              FAQ</a></li>
          <li><a href="http://home.nuug.no/%7Epeter/pf/en/">Firewalling
              with OpenBSD's PF packet filter</a></li>
          <li><a href="http://www.openbsd.org/faq/pf/">PF: The OpenBSD
              Packet Filter</a></li>
          <li><a href="http://www.openbsd.org/faq/pf/example1.html"
              style="font-family: -webkit-standard; font-style: normal;
              font-variant-caps: normal; font-weight: 400;
              letter-spacing: normal; orphans: auto; text-align: start;
              text-indent: 0px; text-transform: none; white-space:
              normal; widows: auto; word-spacing: 0px;
              -webkit-text-stroke-width: 0px;">PF: Example: Firewall for
              Home or Small Office</a></li>
          <li><a href="http://en.wikipedia.org/wiki/List_of_firewalls">List





              of firewalls</a></li>
          <li><a moz-do-not-send="true"
              href="http://en.wikipedia.org/wiki/Defense_in_depth_(computing)">Defense


              in depth</a><br>
          </li>
        </ul>
        &nbsp;
        <meta charset="utf-8">
        <ul>
        </ul>
        <ul>
        </ul>
        <ul>
        </ul>
        <span style="caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0);
          font-family: -webkit-standard; font-size: medium; font-style:
          normal; font-variant-caps: normal; font-weight: 400;
          letter-spacing: normal; orphans: auto; text-align: start;
          text-indent: 0px; text-transform: none; white-space: normal;
          widows: auto; word-spacing: 0px; -webkit-text-stroke-width:
          0px; text-decoration: none; display: inline !important; float:
          none;"><span class="Apple-converted-space"></span></span>
        <ul>
        </ul>
        <br>
        <br>
      </div>
      <!-- <span class="anchor" id="extra"></span> 
--><span class="anchor" id="submission"></span></div>
  </body>
</html>
